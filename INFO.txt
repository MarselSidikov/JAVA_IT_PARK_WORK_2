27(10) -> 11011(2)

27 : 2 = 13 + 1 ост, 27 = 13 * 2 + 1
13 : 2 = 6 + 1 ост, 13 = 6 * 2 + 1
6 : 2 = 3 + 0 ост, 6 = 3 * 2 + 0
3 : 2 = 1 + 1 ост, 3 = 1 * 2 + 1
1
--------------------------
43210 - разряды
11011 - число
1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 27

--------------------------
Какой диапазон чисел можно
 выразить n-количеством битов?
 
 Пусть n = 2, диапазон = 0 .. 2^2 - 1
 
 00 -> 0
 01 -> 1
 10 -> 2
 11 -> 3

 Пусть n = 3, диапазон = 0 .. 2^3 - 1
 000 -> 0
 001 -> 1
 010 -> 2
 011 -> 3
 100 -> 4
 101 -> 5
 110 -> 6
 111 -> 7
 
 int занимает в памяти 4 байта. В одном байте - 8 бит.
 Следовательно, максимальное значение, которое
 можно положить в переменную типа int - 2^32 - 1
 
 НО! На самом деле с int все по-другому.
 Используются только 31 бит из 32-х.
 Потому что 1-й бит уходит под знак числа.
 Если первый бит - 0, число положительное
 Если первый бит - 1, число отрицательное.
 
 1 байт int-а - 8 бит
 00000001 - 1
 10000001 - -1

 Например -27 в int будет выглядеть так:
 int a = -27;
 10000000 00000000 00000000 00011011
 
 В инте на самом деле: -2^31 .. 2^31 - 1
 
 int - 4 байта, -2^31 .. 2^31 - 1 диапазон
 
 int - тип данных
 Тип данных:
 - набор возможных значений 
 - набор возможных операций над значениями
 
 int:
 - целые числа в диапазоне -2^31 .. 2^31 - 1
 - +, -, *, /, %
 
 Объявление переменной на java:
 ТИП имя = нач_знач;
 int a = 27;
 int b; // по умолчанию ноль
 
 / - операция деления. Если слева целое, и справа целое, 
 то выполняется целочисленное деление - остаток полностью отбрасывается
 % - взятие остатка от деления
 То есть:
 Любое число можно выразить формулой:
 n = k * m + t;
 
 n / m = k;
 n % m = t;
 
 У себя в папке с фамилией создаете папку 
 ClassWorks
 Там создаете папку Task1
 В ней сохраняем решение задачи:
 int a = 13768; // сумма, которую хочет выдать банкомат
 // определить количество купюр каждого номинала
 // которое следует выдать банкомату
 5000 - 2
 1000 - 3
 500 - 1
 100 - 2
 50 - 1
 10 - 1
 5 - 1
 2 - 1
 1
РЕШЕНИЕ:
----------------------------
int a = 13768; // 5000 * 2 + 3768
		
		int a5000 = a / 5000; // a5000 = 2
		System.out.println("5000 - " + a5000);
		a = a % 5000; // a = 3 768
		
		int a1000 = a / 1000; // a1000 = 3
		System.out.println("1000 - " + a1000);
		a = a % 1000; // a = 768
		
		// и т.д.
-----------------------------
Именование переменных:
camelCase
camel_case - не так
System.out.println("Hello" + 10);
Выведет - Hello 10
+ - сцепляет строки
Scanner - модуль, позволяющий читать информацию с клавиатуры
Чтобы он работал в программе необходимо его импортировать:
import java.util.Scanner;
Чтобы его использовать необходимо создать его экземпляр:
Scanner scanner = new Scanner(System.in);
Функция nextInt ожидает ввода числа с клавиатуры:
int a = scanner.nextInt();
после того, как пользователь введет число, и нажмет enter оно
попадет в переменную <a>

Домашняя работа:
Создаем на GoogleDrive папку HomeWorks.
В них делаем папки
Task1
Task2
...
В каждую папку заливаем только Program.java - файл

ДЗ:
1) Доделать банкомат, сделать считывание и вывод
всех купюр
2) Считать три числа - a,b,c. Вывести их сумму.
3) Считать два числа - a,b - вывести их частное
4) Считать два числа - a,b - вывести остаток от деления a на b
5) Считать число - 3 знака (0..255), вывести его двоичное представление.
циклы и условия запрещены.

------------------------------------------
Условный оператор if ... else

if (условие_1) {
	действия_при_выполнении_условия_1
} else {
	действия_при_НЕвыполнении_условия_1
}

if (условие_1) {
	действия_при_выполнении_условия_1
} else if (условие_2) {
	действия_при_НЕвыполнении_условия_1
	И_при_выполнении_условия_2
} else {
	действия_при_невыполнении_верхних_условий
}

if (условие_1) {
	действия_при_выполнении_условия_1
}
if (условие_2) {
	действия_при_выполнении_условия_2
}

ОЧЕНЬ ВАЖНО:

Скобки - фигурные { ОБЛАСТЬ_ВИДИМОСТИ }
В области видимости нельзя повторно объявить переменную

МОЖНО:

if (e) {
	int b = 10;
} else {
	int b = 5;
}

НЕЛЬЗЯ:
if (e) {
	int b = 10;
	if (u) {
		int b = 10;
	}
}

a && b - одновременно условие a и условие b истинны
a || b - истинно либо a, либо b, либо одновременно истинны

a += 10; // a = a + 10;
a /= 10 // a = a / 10;

ЦИКЛ - структура управления, делаем действие пока условие цикла
истинно
Один шаг цикла - итерация.

ДЗ:

6) Считать в цикле 10 чисел, посчитать сумму четных
7) Считать в цикле 10 чисел, посчитать произведение нечетных
8) Считать в цикле 10 чисел,  посчитать сумму чисел, оканчивающихся на 7

ТРЕБОВАНИЕ!!!!!
Отступы, форматирование, именование

ДЗ для любимчиков:
ClassWorks - Task3, Task4, Task5
3 - Вывести EVEN если считанное число - четное, NOT EVEN если нечетное
4 - Угадайка
5 - Вывести четные числа от 0 до n, n - с клавиатуры

Условие в циклах и в условных операторах называются "выражениями" - expression
expression имеет тип.

Условие - это такое выражение, которое имеет тип boolean

тип boolean - true/false, занимает в памяти один байт.

Задача: проверить, является ли число простым.

Если число простое - выводим на экран PRIME, если составное - NOT PRIME.
Число подается с клавиатуры.

Простое число - делится на себя и на 1.

Алгоритм проверки простоты числа:
X - входное число
1) Алгоритм в лоб: делить число X на все числа [2..X-1]
2) Алгоритм чуть быстрее: делить число X на все числа [2..x/2]
19
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
3) Алгоритм еще быстрее: делить число X на все числа [2..корень(x)]
	 i * i <= x
Пока (i <= корень(х)) {
	если (x делится нацело на i) {
		сразу говорим, что число не простое
	}
}

если цикл выполнился, и мы не нашли делителей, то говорим, что простое

ВАЖНО:
ПРЕЖДЕ ЧЕМ ИСПОЛЬЗОВАТЬ ПЕРЕМЕННУЮ ЕЕ НАДО ОБЪЯВИТЬ И ПРОИНИЦИАЛИЗИРОВАТЬ

ДЗ:
Везде на вход сначала подается число N, а затем
N-штук чисел

9) Найти минимальное число среди N чисел
10) Найти максимальное число среди N чисел
11) Найти среднее арифмитическое чисел
12) Найти количество локальных максимумов
	a_пред < а_тек > a_след
	а_тек - локальный максимум

6
12
16 - локальный максимум
8
11 - локальный максимум
9
7
ОТВЕТ: 2

БИНАРНЫЕ ЛОГИЧЕСКИЕ ОПЕРАТОРЫ:
a == b - true, если a равно b
a != b - true, если a не равно b
a <= b
a >= b
УНАРНЫЙ ЛОГИЧЕСКИЙ ОПЕРАТОР:
!a - не a, true - если a - false, false - a - true

double - вещественный тип, 8 байтов
СМ. мантисса
https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8

https://ru.wikibooks.org/wiki/Java/%D0%A2%D0%B8%D0%BF%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85

/ - если слева целое и справа целое, то результат тоже целое
/ - если какое либо из чисел вещественное, то результат считается вещественным (с точкой, дробь)
Неявное преобразование - int -> double
Явное преобразование - double -> int, явное преобразование необходимо проводить, когда возможна потеря данных. 

130 в int
00000000 00000000 00000000 10000010
byte:
10000010 - дополнительный код для -127

Что такое дополнительный код?????
-127

В двоичном коде положительное 127
01111110
Код инвертируется - получаем обратный код
10000001
Получаем дополнительный код: прибавляем 1:
10000010

ЗАЧЕМ ЭТО НАДО? 

27 - 5, что делает компьютер:
Заменяет вычитание сложением:

27 + (-5)
Как получить -5?

Пять как положительное:
101
Например, используем 8 разрядов:
00000101
Получаем обратный код:
11111010
Получаем дополнительный код:
11111011
Складываем 27 в двоичном коде и дополнительный код для -5:
 00011011
 11111011
100010110
 00010110

МАССИВЫ - структура данных, представляющая собой
набор переменных.
Каждая переменная доступна по индексу (порядковому номеру)

Объявление массива c последующей инициализацией:
int a[] = new int[5]; // объявили массив из 5 переменных
a[0] = 7;
a[1] = -2;
a[2] = 3;
a[3] = 1;
a[4] = 1;
System.out.println(a[0]); // 7

Явная инициализация массива:
int a[] = {7, 1, 3, 1, 1};

Task7 - Явно проинициализировать массив из 
6 чисел числами 5, 2, 1, 5, 6, 7
Считать два числа i и j.
Поменять местами в массиве элементы под 
позициями i и j. Вывести полученный массив.

5 2 1 5 6 7
при n = 6

a[0] <-> a[6] : a[n - 1 - 0]
a[1] <-> a[5] : a[n - 1 - 1]
a[2] <-> a[4] : a[n - 1 - 2]

i = {0..2}
a[i] <-> a[n - 1 - i]
----------------------------
int i = 0;
while (i < n) {
	System.out.println(i);
	i++;
}
Можно заменить:
for (int i = 0; i < n; i++) {
	System.out.println(i);
}

for (объявление переменной цикла; условие окончания цикла; шаг цикла) {
	// что делаем в цикле
}

ДЗ для всех кроме (Рустем, Валерий, Александр А., Рустам)
13) сумма всех элементов массива
14) среднее арифмитическое элементов массива
15) количество элементов, стоящих на четных позициях
16) разворот массива с помощью цикла for
ДЛЯ ВСЕХ ЗАДАНИЙ МАССИВ ИНИЦИАЛИЗИРУЕМ ЯВНО

ДЗ для Advanced:
17) Удалить из массива все дубликаты
------------------------------------
В java есть две группы типов:
1) примитивные - сама переменная непосредственно 
содержит в себе значение.
int a = 6, в памяти выделяется 4 байта и они
непосредственно хранят в себе значение 6.
оперативная память [][][6][][][][]
						a
К примитивным типам относятся:
int, char, boolean, double, float, byte,
long, short

2) Ссылочные типы данных - переменная хранит
только адрес реального значения.
К ссылочным типам относятся массивы и классы.

int x[] = {-3, 4, 5};

В оперативной памяти выделется память под массив,
и в переменную x кладется адрес первого
байта массива.

оперативная память - [][][][-3][4][5]
оперативная память - [null][][адес -3][][][адрес -3][][]
					 u	      x             y
						 
int y[] = x;
в переменную y скопируется значение x

int u[]; // u - null
----------------------------------
Сортировка массива - упорядочивание элементов массива
-4 5 1 2 10 12 -7 => -7 -4 1 2 5 10 12

Сортировка вставками:

Пусть есть массив x[0..n-1]
1) Положим a = 0, b = n-1
2) Найдем минимальный элемент min в дапазоне [a..b]
3) Поменяем местами x[a] <=> min
4) Теперь a = a + 1
5) Повторим шаги 2-5

Реализация:
-4 5 1 2 10 12 -7, min -7
-7 5 1 2 10 12 -4, min -4
-7 -4 1 2 10 12 5, min 1
-7 -4 1 2 10 12 5, min 2,
-7 -4 1 2 10 12 5, min 5
-7 -4 1 2 5 12 10, min 10
-7 -4 1 2 5 10 12, min 12
-7 -4 1 2 5 10 12 - конец

Сортировка пузырьком:

Пусть есть массив x[0..n-1]
1) Пусть i = n -1
2) Пусть j = 0
3) Пока j меньше i, если x[j] > x[j+1], меняем местами 
4) Дошли до i -> i - 1, повторяем 2-4

-4 5 1 2 10 12 -7

при i = n - 1 = 6 
-4 и 5 - -4 меньше, все нормально
-4 5 1 2 10 12 -7
5 и 1 - 5 больше, меняем местами
-4 1 5 2 10 12 -7
5 и 2 - 5 больше, меняем местами
-4 1 2 5 10 12 -7
5 и 10 - 5 меньше, все нормально
-4 1 2 5 10 12 -7
10 и 12 - все нормально
-4 1 2 5 10 12 -7
12 и -7 - меняем местами
-4 1 2 5 10 -7 12 - самое большое число в конце

теперь i = i - 1, повторяем все заново

ДЗ:
18) Реализовать вставками без гугла
19) Реализовать пузырька тоже без гугла

Пример вложенного цикла:
for (int i = 0; i < 5; i++) {
	for (int j = 0; j < 5; j++) {
		System.out.println(i + j);
	}
}

Для i = 0 программа выведет:
0 + 0 = 0
0 + 1 = 1
0 + 2 = 2
0 + 3 = 3
0 + 4 = 4
Для i = 1 программа выведет:
1 + 0 = 1
1 + 1 = 2
1 + 2 = 3
1 + 3 = 4
1 + 4 = 5
----------------------------------------
Задача: 
Пусть int a[] = {4, 5, 9, 2, 1};

Надо, чтобы в x = 45921;

7324 = 7 * 1000 + 3 * 100 + 2 * 10 + 4 * 1

Task13
Считать число - 3 знака (0..255), 
вывести его двоичное представление.
Циклы, условия и массив необходимы

-------------------------------------------------------
int, double, boolean
long  float
short
byte

char - символьный тип, 2 байта

Таблица кодировки - каждому символу
сопоставляется определенное число.

Две наиболее известные кодировки:
ASCII
0 - 31 управляющие непечатные символы
\n - переход на новую строку
\t - табуляции
\r - возврат каретки
32 - 127 - печатные символы латинского алфавита
65 - 90 - заглавные буквы английского алфавита
97 - 122 - строчные буквы английского алфавита
127 - 255 - печатные символы регионального языка

Один символ в кодировке ASCII занимает 1 байт

проблемы - если на машине не установлен язык,
документ превращается в крякозябры

Решение - выделить под каждый символ 2 байта
Таким образом можно закодировать 65 000 символов 
- это Unicode 

char -> int неявное преобразование
int -> char - явное преобразование

ДЗ:
20) Пусть имеется сторка '3','2,'3','1', надо получить
число int x = 3231
21) Получить text аналогично как в 21 и вывести
все знаки препинания
22) Считать два массива символов с консоли:
char text[] - максимальная длина 100
char word[] - максимальная длина 10
Сначала считать число n - количество 
символов в text, которые вы захотите ввести
Потом считать сами символы text
аналогично для word
Найти позицию вхождения word в text
Например:
text = abbbabbc
word = bc
Результат работы программы: 6


----------------------------------
Подрограммы - наборы инструкций, внутри основной программы.
Данный набор может быть многократно вызван по имени.

Придумали:
1) Чтобы избежать дублирования кода
2) Чтобы избежать ошибок

Вид подпрограммы:

имя(набор_формальных_формальных_параметров) {
	// тело подпрограммы
}

Подрограммы - функции и процедуры

Процедура - набор инструкций с именем, телом и формальными парамтами

static void имя_процедуры(набор_формальных_параметров) {
	// тело
}

Вызов процедуры:
имя_процедуры(набор_аргументов).
Аргументы передаются в формальные параметры

main - входная точка приложения - процедура.

Аргументы в формальные параметры копируются.
В формальный параметр копируется значение аргумента.
Если аргумент примитивный - копируется содержимое.
Если аргумент ссылочный - копируется ссылка на объект в памяти.
Таким образом процедура работает с самим объектом.

Task15
Написать процедуру вывода всех чисел массива,
меньших числа number
static void showLess(int array[], int number)

Task16
Минимальный и максимальный элементы поменять местами

Функция - разновидность подпрограммы.
Функция в отличие от процедуры может явно возращать
значение своего выполнения.

public static int sum(int a, int b) {
	int s = 0;
	for (int i = a; i <= b; i++) {
		s = s + i;
	}
	
	return s;
}

// return - возвращает значение туда, где была вызвана функция
public static void main(String args[]) {
	int mySum = sum(5, 10); // после выполнения функции вместо sum(5, 10) будет лежать значение суммы
	double average = mySum / 6.0;
}

Task16
Написать три функции - 
поиск минимального в массиве, {2, 3, -4, 3} -> -4
поиск максимального в массиве {2, 3, -4, 3} -> 3
поиск номера элемента в массиве {2, 3, -4, 3}, -4 -> 2, первое вхождение, если ничего не нашли -1
процедура, меняющая в массиве элементы i и j
Процедура:
Поменять максимальный и минимальный элементы местами
используя описанные функции

ДЗ:
Доделать классные и разобрать

--------------------
Добавление элемента в конец массива
Пусть есть пустой массив A
[ ] [ ] [ ] [ ]
 0   1   2   3

Если добавляем * в массив, куда мы ее положим? - A[0]

[*] [ ] [ ] [ ]
 0   1   2   3

Теперь, куда добавим еще одну *? - A[1]

[*] [*] [ ] [ ]
 0   1   2   3

----------------------------
Добавление элемента в начало массива
[*] [**] [***] [ ] [ ]
  0   1     2    3   4
Как добавить в начало ****?
1) [*] [**] [***] [***] [ ]
    0     1    2     3   4

2) [*] [**] [**] [***] [ ]
3) [*] [*] [**] [***] [ ]
4) [****] [*] [**] [***] [ ]

Задача:

Скопировать мой код

addToIndexOfArray(int a[], int value, int index)

------------------------------------------
Типы данных - примитивные, ссылочные - массивы.
Это встроенные типы.

Пользовательские типы - типы, определенные программистом.
Такие типы - абстрактные.

Абстрактные типы данных ~ классы.

Это типы данных, полученные методами
абстракции.

Абстракция - сущность, характеристики
которой определены в контексте
решаемой задачи. То есть эта сущность
имеет только те характеристи, которые
необходимы для решения задачи.

Сущность "Студент" - абстракция.

Задача: университет
- имя, фамиля, возраст, номер группы
- академ. задолженность
- отработаны ли мероприятия

Задача: семья
- накормлен ли
- где он в субботу вечером
- с кем он в субботу вечером
- ориентация
- в каком состоянии

Задача: военкомат
- когда, где, почему

Класс - общая структура, абстракция.
На основе классов создаются объекты - реальные сущности.
объект - сущность, обладающая:
- параметрами, свойствами, характетиристиками, - СОСТОЯНИЕ
- ПОВЕДЕНИЕ - что может делать объект

Теперь, каким образом мы можем описать класс?

1) Описать, объект может иметь диапазон характеристик
2) Описать его поведение

Как можно описать объект?
Создать его на основе класса, а затем
задать ему характеристики

------------
1) ДЗ - написать класс Животное с его
характеристиками, создать два экземпляра
вывести на экран характеристики каждого
2) В проекте ArraysWorks добавить
метод сортировки пузырьком или вставками
и протестировать на animalsWeight

Два важных понятия жизненного цикла объекта:

1. Шаг - инстантивация - создание экземпляра, выделение памяти (оператор new)
2. Шаг - инициализация - задание начальных характеристик - конструктор

Конструктор - очень похож на метод, но
таковым не является. Набор инструкций, инициализирующих
объект.

По умолчанию каждый класс имеет конструтор без параметров.
Данный конструктор "по умолчанию" инициализирует
каждое поле ее дефолтным значением.
Для int -> 0
Для boolean -> false
Для ссылочных типов (включая String) -> null
Для double -> 0.0

Конструкторы можно определять самим. Но, тогда
конструктор по умолчанию становится недоступным.

ИТОГО:
Конструторы бывают четырех:
1) Конструтор "по умолчанию без параметров"
2) Конструктор пользовательский без параметров
3) Конструктор пользовательский с параметрами
4) Конструктор пользовательский копирования - инициализирует объект полями другого объекта

this - ключевое слово, указываемое перед обращением
к члену класса внутри самого класса.
this - объектная переменная.
DEBUG - отладка программы.
Breakpoint - точка останова. Строка, на которой
программа должна остановить выполнение.

Программист на Java всегда выступает в двух ролях:
1) Разарботчик класса, когда разрабатываем класс мы не пишем инструкции программе, мы
лишь говорим, как она может работать у пользователя.
2) Пользователь класса - пользуется теми инструкциями, которые
описал разработчик класса.

В Main обычно пишут вызовы доступного функционала.

Помимо полей, членами класса также являются методы.
Метод - функция либо процедура описанная внутри класса.

Task17

Описать класс Автомобиль
Поля класса:
Модель
Номер (только числа)
Пробег
Сколько было потрачено топлива
-----
Конструкторы - 
без параметров, 
копирования, 
с параметрами
Методы - 
рассчитать средний расход бензина на 1 км.

В Main все вывести.

http://www.ozon.ru/context/detail/id/7821666/

Пакеты - по сути, папочки.
Нужны для логического разделения классов.
Пусть есть класс cursor - их два.
Один - мышка
Другой - каретка в файле
Называются одинаково. Как разделить?
один - ru.itpark.windows, ru.itpark.text;
Полное имя класса всегда включает пакеты.

Уровни доступа - обычно распространяются на члены 
классов и конструкторы.

Есть 4 уровня доступа:
Закрытый
Открытый
Защищенный
Пакетный

Если у члена класса или конструктора не указан модификатор доступа,
то считается, что у него пакетный уровень доступа

public - модификатор доступа, соответсвующий уровню
доступа открытый. Доступен всегда и везде.

private - модфикатор доступа, соответсвующий уровню доступа
закрытый. Доступен только внутри класса.

В поля класса могут лететь неккоректные данные.
Чтобы обезопасить объект необходимо:

1) Сделать поля закрытыми (private)
2) Сделать set-методы с проверкой данных

Первый принцип ООП - абстракция
Второй принцип ООП - инкапсуляция
1. Совмещение в одной сущности структур данных (поля)
и алгоритмов (методы).
2. Защита внутренней структуры данных
Для чего это нужно?

ИТОГО:

В классе есть
Поля
Конструкторы
Методы
Методы доступа (get-set методы)

Генерация геттеров, сеттеров и конструкторов:
Ставим курсор в текстовое поле с классом
Нажимаем Alt+Insert
Выбираем поля и радуемся жизни

ДЗ 
25):

Описать класс Человек
Имя
Возраст
Пол
Рост
Вес

+ Конструкторы
+ Геттеры
+ Сеттеры
+ Поля

---------------
26) Для Advanced:
Создать массив людей
Данные считать с клавиатуры
Далее, считываете фильтр сортировки:
- по возрасту -> 1
- по росту -> 2
- по весу -> 3

Сортируете, выводите на экран

Список - АТД, поддерживающий опреации
работы с коллекцией как со списком:
положить
удалить
найти
заменить
и т.д.

Список на основе массива - в качестве
хранилища элементов массив - ArrayList

Реализовать концепт Телевизор
ТелевизоР это набор каналов,
каждый канал - набор передач
Есть пуль, пулТь переключает канал
Есть человек, он нажимает на кнопки пульта.
--------------------

Статическое поле (например static int aStaticValue):
1) Является глобальным для всех объектов класса.
2) Могут быть вызваны непосредственно из класса, 
без создания объекта.
3) Могут быть вызваны ДО создания объектов.
4) Нестатические поля инициализируются в конструкторе.
А статические поля инициализируются в статическом инициализаторе.

Зачем они нужны?
Когда поле должно быть глобальным для всех объектов, например:
время для программы
счетчик созданных объектов и т.д.

Нужны статические поля-константы, например 
число PI

Статические методы:
1) Могут быть вызваны из класса без создания объекта
2) Могут работать только со статическими полями класса

Когда нужны статические методы:

КОГДА МОДЕЛИРУЕТСЯ ПОВЕДЕНИЕ ПРЕДМЕТНОЙ ОБЛАСТИ
а не конкретных объектов, например:
Математические функции
Сортировки

ДЗ:
27) Сделать копию ArrayList к себе
    Добавить функции:
    получить пересечение списков (формирует список с элементами, которые есть в двух других (и там и там))
    удалить все дубликаты из списка
28)
    Ресторан - смоделировать предметную область


Advanced:
Изучить связыне списки
Описать класс Node {
	int value;
	Node next;
}
Описать класс LinkedList(имеет поле Node head)
+ реализовать все методы, которые есть в ArrayList
+ изучить внутренние и вложенные классы, 
описать Node как вложенный класс по отношению к LinkedList

-------------------
Наследование:

- Третий принцип ООП. Позволяет объектам классов-потомков
копировать и дополнить (состояние 
и поведение) и переопределять поведение объектов классов-предков.

Наследование в java
Пусть A потомок класса B.
Чтобы это было действительно так, надо написать:
class A extends B {

}
При этом класс А становится потомком класса B, 
и внутри класса A присутствует возможность вызвать
конструктор класса B через super().

Для того, чтобы класс A имел доступ к полям 
класса B, в классе B поля должны быть помечены
модфикатором доступа public/protected.
К полям предка можно обращаться через super (аналогично this).

КОНСТРУКТОР НИКОГДА НЕ НАСЛЕДУЕТСЯ!!!!!!

Пусть класс B имеет метод x();
Если в классе A нет описания метода x(),
то такой вызов: A a = new A(); a.x();
вызовет метод класса B.
Если же мы в классе A напишем СВОЮ реализацию
метода x(), то вызов A a = new A(); a.x();
даст вызов метода в классе A.
Такой механизм называется ПЕРЕОПРЕДЕЛЕНИЕМ МЕТОДА.
ВАЖНЫЙ МОМЕНТ!!!!!!!
метод в потомке должен ПОЛНОСТЬЮ ПОВТОРЯТЬ СИГНАТУРУ МЕТОДА В ПРЕДКЕ
(тип возвращаемого значения, название, формальные параметры)
Если метод в предке и потомке отличаются по:
1. Названию - то это вообще разные методы
2. Если методы отличаются формальными параметрами
то это перегрузка методов.
3. Если методы отличаются типом возвращаемого
значения -будет ошибка.
В Java могут быть два метода с одинаковым названием
и разными формальными параметрами.
Восходящее преобразование.

Объектная переменная - переменная, которая
может содержать ссылку на объект.
У объектной переменной есть тип. Но объект, на который
ссыллаестя объектная переменная не всегда
может быть того же самого типа.

Восходящее преобразование - возможность хранить
в объектной переменной класса-предка ссылку
на объект класса потомка.

Полиморфизм - возможность работать
с объектами разного типа таким образом,
будто они принадлежат одному типу.

Возможность обеспечивается восходящим преобразованием.

Рекомендации по наследованию:
1. Не использовать наследование.
2. Если уж вас угораздило - используйте правило: Класс
A потомок класса B тогда, и только тогда, 
кода любой объект A является B.

Супермен потомок Супергероя, потому что
любой супермен является супергероем.

Велосипед, является потомком транспорта, 
потому что любой велосипед является транспортом

Задание номер:
Task18
Классы прямоугольник, квадрат, трапеция.
Задача: построить правильную иерархию классов
+ вывести на экран площадь каждой фигуры.

Абстрактный класс - класс, экземпляры которого
не могут быть созданы.
Для чего они нужны? Для ЛУЧШЕГО построения иерархий классов, 
а также для более качественного использования полиморфизма.

Абстрактные классы в Java помечаются 
ключевым словом abstract. Экземпляры
таких классов создать нельзя.

Абстрактный метод - метод, у которго нет реализации.
Если в классе есть хотя бы один абстрактный метод,
то весь класс помечается как abstract.
Такие методы ОБЯЗЫВАЮТ всех потомков
данного класса реализовать данный метод.
Если потомок не реализует данный метод,
то он тоже должен быть помечен как abstract.

Task 19
1. Скопировать код Task18 в папку Task19
2. Задача: вывести количество одинаковых фигур.
Фигуры считаются одинаковыми, когда у них
одинаковый периметр и площадь.

Множественное наследование - принцип, когда у 
потомка может быть более одного предка.

В Java множественное наследование запрещено.
НО!
Разрешена множественная имплементация интерфейсов.
Интерфейс - технически - это полностью абстрактный класс,
содержит только абстрактные методы + константы 
(до Java 7).

Интерфейс - семантически - абстракция поведения.

SOLID

https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

S	SRP[5]	
Принцип единственной ответственности (The Single Responsibility Principle)
Существует лишь одна причина, приводящая к изменению класса.
O	OCP[6]	
Принцип открытости/закрытости (The Open Closed Principle)
«программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
L	LSP[7]	
Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование.
I	ISP[8]	
Принцип разделения интерфейса (The Interface Segregation Principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»[9]
D	DIP[10]	
Принцип инверсии зависимостей (The Dependency Inversion Principle)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»[9]

Сравнение в Java:
1) Сравнение примитивных типов
== - сравнивает значения переменных примитивных типов
2) Сравнение ссылочных типов
== - сравнивает ссылки, которые хранятся в сравниваемых объектных переменных 
Сравнение ссылочных типов (классов) по полям можно сделать
переопределив метод equals класс Object.
Метод equals принимает на вход Object, следовательно
вы не можете получить доступ к полям, пока не 
выполните понижающее преобразование.

Класс Object - суперкласс.
Любой класс Java по-умолчанию наследуется от Object.
ЧТО МЫ ЗНАЕМ:

1) Типы данных - int, boolean, double, char операции над ними и размер
2) Утилиты java и javac
3) if, while, for
4) System.in, System.out, System.err
5) Бинарные унарные логические операторы
6) Явное и неявное преобразования
7) переполнение
8) обратный, дополнительный коды
9) массивы, сортировки - пузырьком, вставками
10) Классы, объекты
11) Поля, методы, конструкторы
12) Функции, процедуры -> методы
13) Инкапсуляция
14) Уровни доступа и модификаторы доступа
15) Методы доступа
16) Статические члены классов
17) Наследование, абстрактные классы
18) Полиморфизм, интерфейсы
19) Перегрузка и переопределение методов
20) SOLID
21) Object + equals
22) InputStream OutputStream + FileInputStream + FileOutputStream
23) Сериализация

Advanced TASK:
Сгенерировать список людей из 17 000 записей
Сохранить в файл.
Каждая запись содержит имя возраст.
Считать все это дело из файла, и отсортировать
по возрасту за O(n).
Результат записать в другой файл.
ООП!!!!

////
http://developer.alexanderklimov.ru/android/java/io.php
http://iais.kemsu.ru:8080/odocs/java/Chapter11.html
////

Файл - набор байт на жестком диске с последовательным доступом
Streams - потоки интсрументы, с помощью которых
Java работает с последовательностями байт.
Поток - последовательность байт.
Поток может быть из клавиатуры, из камеры,
может из файла.
По умолчанию Java открывает три потока:
System.in
System.out
System.err

 Пакет java IO(input/output) предназначен для работы с потоками.
 InputStream - верхний класс java IO, отвечает
 за работу с входными потоками.
 Методы:
 * int read() - возвращает один байт из входного потока.
 и переходит к следующему байту.
 Метод возвращает значение от 0 до 255.
 Тип byte не используется потому, что его
 диапазон значений в промежутке -128..127.
 Метод возвразает -1, когда данных.
 * int read(byte b[]) - считывает набор байтов из потока
 в массив b и возвращает количество считанных байт
 FileInputStream - потомок класса InputStream.
 В нем реализован метод read вызовом методоа
 read0, который является native.
 native методы - реализованы в виртуальной машие, реализованы нативно, 
 то есть на C/C++

 OutputStream и его потомок FileOutputStream.
 Работают с выходным потоком.
 
 имеют методы write(int b); write(byte[] b);
 
 ДЗ:
 Реализовать nextInt в своем классе Scanner

 class Scanner {
	private InputStream input;
	
	public Scanner(InputStream input) {
		this.input = input;
	}
	
	public int nextInt() {
		// считываете байты, пока не встретили цифру
		// встретили цифру, преобразуете в int и запоминаете
		// пока у нас идут цифры, каждое преобразуем в int
		// и запоминаем
		
		// возвращаем результат
	}
 }

Сериализация - преобразование объекта в байтовое представление.
-------------------------
У программистов часто возникают одинаковые проблемы.
Наиболее известные:
1. Необходимость создания объекта только в единственном экземпляре. - Паттерн Singleton
2. Необходимость организации системы таким образом, чтобы компонент А следил за событиями в компоненте B. - Паттерн
Listener, Observer, Handler, Наблюдатель или Слушатель
3. Необходимость обеспечения независимости логики системы
от хранилища данных. Точнее от типа хранения (Текстовые файлы, сериализованные объекты, SQL-база данных, MongoDB) - 
Для решения таких проблем существует набор правил. Каждое правило описывает требования к реализуемым классам. Такие 
наборы правил являются шаблонами, и называются - паттернами.
Есть паттерны поведения, есть паттерны проектирования.
-------------------------
Исключения в Java.
Исключительная ситуация - ошибка.
Ошибку следует обрабатывать, чтобы система не падала.
Если есть фрагмент кода, где может быть ошибка, мы помечаем
этот фрагмент кода блоком try {..}. Далее, указываем в блоке catch, что мы сделаем, если возникнет ошибка в блоке
try.
-------------------------
Паттерн Singleton
Необходимо иметь строго один объект во время выполнения.
Logger - класс, записывающий данные во время выполнения программы с целью анализа и устранения проблем.

Проблема - логгер на всю систему должен быть ОДИН, что бы данные писались одинаково в одни и те же файлы, или в одну и ту же консоль

public class Logger {
	
	// необходимо создать поле, которое бы 
	// хранило единственный экземпляр класса
	private static Logger instance;
	
	// необходимо предоставить доступ к полю instance
	public static Logger getLogger() {
		return instance;
	}
	
	static {
		instance = new Logger("log.out");
	}
	
	// но нам же нужно как-то его инициализировать
	// например, сообщить, в какой файл нужно писать данные
	
	// поле-файла, куда нужно писать данные
	private FileOutputStream fileOutputStream;
	
	// открытый конструктор позволяет создавать объекты
	// значит надо конструктор сделать приватным
	private Logger(String fileName) {
		try {
			this.fileOutputStream = 
				new FileOutputStream(fileName);
		} catch(Exception e) {
			System.err.prinln("Проблемы с файлом");
		}
	}
	
	public void log(String message) {
		// записать сообщение
	}
}

В итоге в main все будет выглядеть та

public static void main(String agrs[]) {
	Logger log1 = Logger.getLogger();
	Logger log2 = Logger.getLogger();
	
	// log1 и log2 содержат один и тот-же объект
	log1.log("Hello!");
	log2.log("Hello!");
}


------------------------------------------
Отношение между сущностями и их хранение.
Человек
Автомобиль
Квартира

Человек-автомобиль
У одного человека может быть несколько автомобилей
Как хранить подобную информацию:
Связь: один ко многим
Файл Человек
id имя фамилия возраст 

Файл Автомобиль
id Модель Цвет id_владельца

Человек-Квартира
У одного человека может быть несколько квартир,
у одной квартиры несколько хозяев
Связь: многие ко многим
Как хранить подобную информацию:
Файл Человек
id имя фамилия

Файл Квартира
id площадь адрес 

Файл Квартира_Человек
id_квартиры id_человека

Человек_паспорт_РФ
Связь: один к одному, у одного человека один паспорт,
у одного паспорта один человек
Файл человек
id имя фамилия возраст id_паспорта

Файл паспорт
id серия_номер дата_выдачи id_человека

---------------------------------------------
Пусть есть два класса: A и класс B.
В классе A необходима 
функциональность класса B.
Способы решения проблемы:
1) Наследование. A extends B. тогда в классе 
A будут все методы класса B.
Проблемы: неконтролируемое поведение класса А,
если в класс B будут добавлены какие-то методы,
то в классе A они также будут присутствовать
(пример Agreg/a)
Решение:
2) Агрегирование - в классе A создается поле
типа B. И внутри A используются только необходимые
методы класса B. 
Проблема: инициализация класса B внутри A.
А что елси мы хотим настроить определенную конфигурацию
для класса B, тогда нам придется заботиться
об этом внутри класса A
(пример Agreg/b).
Решение:
3) Передача инициазилированного B в класс A
Проблема: а если мы захотим сменить реализацию 
класса B? Заменить на класс X. Тогда в классе A
придется изменять код инициализации поля b.
(пример Agreg/с).
Решение:
4) Использование агрегирования со слабой связью.
Создается интерфейс C, который реализуют как
B так и X, и в классе A мы имеем поле типа C. 
(пример Agreg/d).
---------------------------------------------
------------------------------------
Есть система, в ней заложена какая-то логика.
Такая логика системы называется бизнес-логикой
Пример бизнес-операции:
1. Получить от пользователя пароль
2. Предоставить ему набор досутпных операций
3. Получить запрос на снятие денег
4. Записать в хранилище информации о снятии
5. Снять деньги посредством внесения записи в хранилище
6. Отправить смс-клиенту
7. Выдать деньги
Бизнес-логика взаимодействуем с хранилищем данных.
Бизнес-логика - отдельный набор классов
Согласно принципам SOLID система не должна
жестко зависеть от других систем.
-------------------------------------
Добавить машину пользователю.
Бизнес-логика:
1) Получить машину
2) Получить идентификатор пользователя, которому
хотим добавить машину.
3) Проверить, есть ли действительно в системе такой
пользователь.
4) Если есть - добавить ему машину, если нет - сообщить клиенту.

Паттерн проектирования DAO - DataAccessObject
Суть: использование DAO-интерфейса для работы с 
хранилищем. Таким образом, бизнес-логика
не зависит от того, как будет реализовано хранилище данных.

------------------------------------
1) Пусть мы описали тип хранилища 
ArrayList - это хранилище элементов,
обертка над массивом
Быстрые операции добавления в конец
Быстрые операции получения по индексу
Задача: использовать данный тип хранилища
дляя элементов любого типа
Решение 1: Использовать Object-массив.
Поскольку класс Object является супер-классом,
то любой объект приводим к этому типу.
Таким образом, массив Object может хранить
элементы любого типа.
Минусы - нет гарантии единства типов
элементов списка
Решение 2:
Использование параметризации
Параметризованный класс, класс объявленный
с diamonds-оператором <T>
В качестве параметра можно подставлять любой
java-тип (класс)
Плюсы: гарантия типового единообразия.
То есть все поля типа T в классе будут одного типа.
Параметризация - синонимы - обощения,
дженерики
НЕ ПУТАТЬ ДЖЕНЕРИКИ С ШАБЛОНАМИ (В С++)
-------------------------------------
Коллекция - набор элементов
- Списки List
	* положить значения
	* удалить значение
	* получить по индексу
	...
- Ассоциативные массивы (словари, карты) - Map
	* положить значение по ключу
	* получить значение по ключу 
	...
- Множества - все элементы уникальные - Set
----------------------
Коллекции в Java:
Иерархия коллекций

Iterable<T> - интерфейс,      Map<K,V> - интерфейс
позволяющий итерировать 
коллекции(проходить 
по одному элементу)
	^
	|
	|
Collection<E> - интерфейс,
позволяет добавить элемент
в коллекцию
boolean add(E e);
    ^
	|
	|
List<E> - интерфейс,
помимо функционала коллекций,
предоставляющий функционал получения
элемента по индексу
E get(int index);
	^
	|
	|
ArrayList<T> - класс, 
представляющий собой список
на основе массива.
ОСНОВНАЯ ОСОБЕННОСТЬ:
автоувеличение
Разбор класса ArrayList
Поля:
Object[] elementData;
- хранилище данных
private int size; 
- количество заполненных ячеек массива
private static final int DEFAULT_CAPACITY = 10;
- по умолчанию 10 элементов в массиве
Методы:
public void add(E e) -
метод добавления элемента
в массив
public boolean add(E e) {
		// работа с увеличением размера массива
		// обеспечить емкость для добавление нового элемента
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        // кладем элемент в массив
		elementData[size++] = e;
		// возвращаем результат об успехе
        return true;
    }

// метод обеспечения емкости
// минимально необходимая емкость
private void ensureCapacityInternal(int minCapacity) {
		// если элементов вообще нет
        // говорим, что теперь минимальная емкость это
		// либо 10, либо требуемая, если она больше
		if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
		// обеспечить реально-необходимую емкость
        ensureExplicitCapacity(minCapacity);
    }


 private void ensureExplicitCapacity(int minCapacity) {
        // забить на эту инструкцию
		modCount++;

        // считаем разницу между 
		// необходимым объемом
		// и сколько есть
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }

	// функция увеления размера массива
	private void grow(int minCapacity) {
        // запоминаем старый объем
        int oldCapacity = elementData.length;
		// высчитываем новый объем - в полтора раза больше предыдущего
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        // если новый объем оказался меньше
		// необходимого, то новый объем = необходимый
		if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
		// если новый объем больше максимального размера массива
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        // копирование старых данных в массив бОльшей размерности
		// copyOf вызывает функцию System.arraycopy - нативная, поэтому выполняется быстро
		elementData = Arrays.copyOf(elementData, newCapacity);
    }
	
	private static int hugeCapacity(int minCapacity) {
        // если размер меньше нуля
		if (minCapacity < 0) // overflow
		// выбрасывается ошибка
            throw new OutOfMemoryError();
        // в противном случае
		// возвращается либо максимальное значение Integer
		// либо максимально-возможный размер массива
		// тернарный условный оператор
		return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }


ДЗ:
ЗАДАЧА:
Реализовать функционал для работы с квартирами.
1) Добавить пользователя
2) Добавить квартиру
3) Добавить квартиру пользователю
4) Настроить IdGenerator на пользователей и квартиры
5) Реализовать в DAO метод findAll, который возвращает
все значения из файлов кваритр, пользователей, машин 
в каждой DAO свой список сущностей

-----------------------------
Maven - инструмент, решающий две большие задачи:
1. Сборка проекта
2. Управление зависимостями

Идентификаторы maven-проекта:
group-id - идентификатор компаниии-разработчика. Например:
org.postgresql
org.springframework
com.google

artifact-id - непосредственный идентификатор
проекта. Содержит название проекта:
guava
driver
spring-mvc

version - версия

Структура maven-проекта:
src - файлы исходного кода
	- main - основной код
		- java - файлы исходного кода на java
		- resources - вспомогательные ресурсы
	- test - модульные и прочие тесты 
target - результаты сборок/компиляций
pom.xml - файл проекта, содержит информацию о проекте и зависимостях

Жизненный цикл Maven-проекта
clean - удаление папки target
compile - компиляция
package - сборка jar

Для того, чтобы подключить сторонную библиотеку
надо найти его идентификаторы в MavenRepository и вставить в pom.xml
------------------------------------------
GIT - система контроля версий
Сервер (например github.com) содержит в себе репозиторий проекта. (исходный код + полная история)

Каждый разработчик клонирует проект к себе.
Вносит изменения, фиксирует файлы, в которых
есть изменения, делает "коммит", далее, комит 
пушится на удаленный репозиторий.

Другой разработчик, имеющий у себя на компьютере локальную копию, может спуллить (обновить) изменения удаленного репозитория.

ТЕРМИНЫ:
- клонирование
- коммит
- пуш
- пулл

Создание своего репозитория через сайт.
1. Зайти на сайт гитхаба и залогинится.
(предварительно пройти регистрацию с подтверждением емейла)
2. Переходим во вкладку Repositories
3. Нажимаем на new
4. Вводим имя репозитория JAVA_IT_PARK_WORK_2
5. Create Repository
6. Откроется страница с пустым репозиторием
7. Копируем ссылку на репозиторий
8. Открываем Git Bash
9. Командой cd переходите в нужную папку
10.	Клонируем репозиторий командой git clone 
ссылка_на_репозиторий
11. Переходим в папку с репозиторием

------
Работа с репозиторием:
1. Изменение, добавление, удаление файлов.
2. Добавляете файлы в коммит с помощью git add .
3. Делаем коммит:
git commit -m 'текст сообщения'
4. Пушим изменения
	а) в первый раз: git push origin master
	б) далее просто: git push
git diff имя_файла - показывает разницу между изменениями и последним коммитом
5. Коммиты можно накапливать без заливания в репозиторий
6. ДОМА ВЫ ДЕЛАЕТЕ git pull и на работе git pull

ЗАДАЧА:

1. СОЗДАТЬ ЗДЕСЬ СВОЙ РЕПОЗИТОРИЙ В ПАПКЕ С ФАМИЛИЕЙ
2. Перенсти туда все файлы, залить на удаленку 
3. Дома склонировать, добавить туда домашки
-------------------------------------------
Задача:
Обеспечить возможность работы с данными
разных сущностей на основе файловой системы.
Набор опреаций, доступный над каждым набором:
Сохранить
Обновить
Удалить
Найти
Найти все
Сигнатуры всех операций перечислены в интерфейсе
BaseDao.
Интерфейсы DAO для каждой сущности расширяют данный интерфейс и добавляет дополнительные необходимые методы.

Поскольку работа данных методов шаблонная и требует знания:
1) файла
2) сущности
3) отображения сущности из строки файла
и др. было принято решение создания шаблонного класса для работы с этими сущностиями - FileDaoTemplate

Реализация метода поиска сущности по значению какого-либо из параметров:
Создается обобщенный метод 
public <T> T findByValue(String fileName, int valueColumn, Object value, RowMapper<T> rowMapper)

Данный метод позволяет найти сущность по какому либо из параметров.
T - тип сущности, вычисляется из указанного типа в RowMapper

RowMapper - интерфейс, отображающий строку файла в объект.

В каждой из DAO указана своя реализация RowMapper-а

1) Подключить Maven
2) Переопределить toString у всех моделей
(квартира, человек, машина) с помощью guava
3) Добавить в template методы по сохранению сущностей для квартир, людей и машин. На вход метод должен принимать генератор id-ек. (на каждую сущность делаем свой генератор).

Жду: код на гитхабе с выполненным ДЗ, и не за два часа до занятия =)
----------------------------------------------------
Поток - элемент процесса. В отличие от процесса не отображается в диспетчере задач,
и не имеет своего адресного пространства.

Свойства потоков 
- имя
- родительский поток
- приоритет

Thread.currentThread() - возвращает поток, из которого был вызван этот метод
run - метод, который необходимо переопределить, при наследовании от класса Thread. Здесь мы указываем инструкции потока.
start - метод, который необходимо вызвать для исполения инструкций метода run в отдельном потоке.
Если вызвать run, а не start, то инструкции будут выполнены в потоке, который вызвал метод run.
join() - поток, который вызвал этот метод у другого потока будет ждать завершения последнего.
Thread.sleep(12) - усыпляет текущий поток на 12 милисекунд.
------------------------------------
Исключительная ситуация (Exception) - отклонение от нормы, ошибка.

1. Ошибка компиляции - кривые руки разработчика (незнание синтаксиса).
2. Ошибки времени выполнения - происходят либо из-за неправильной архитектуры, либо из-за действий пользователя.

Изучем 2-ую группу ошибок.

В java все исключения - объекты определенных классов. Так как ошибки выбрасываются либо системой либо пользователем, то класс, который обобщает все исключения называется Throwable.

Throwable: 

Throwable getCause() - метод, который возвращает ошибку, которая послужила причиной данной ошибки.

String	getMessage() - сообщение, сопроваждающее исключение.

printStackTrace() - напечатать список вызвов для данной ошибки.

Два подкласса Throwable:
- Error (непроверяемые исключения) - системные исключения
	- VirtualMachineError - исключение виртуальной машины.
		- OutOfMemoryError - выход за границы памяти 
		- StackOverflowError - переполнения стека
- Exception (проверяемые исключения)
	- RuntimeException (непроверяемые исключения)
		- ArithmeticException - арифмитические ошибки (например, деление на ноль)
		- NullPointerException - ошибка нулевого указателя, при работе с нулевой объектной переменной
	- Все остальные потомки - проверяемые 

Для обеспечения корректной работы программы, исключения можно перехватывать
try {
	// блок кода, где может возникнуть исключение
} catch(КЛАСС_ИСКЛЮЧЕНИЯ объектная_переменная_исключения) {
	// интрукции, которые необходимо выполнить, когда возникло исключение
}
---------------------------------
----------------------------------------------------
Файловое хранилище данных:
1. Нет гарантии целостности данных (34 Марсель 2-id квартиры), нет никакой гарантии, что квартира с id 2 вообще существует.
2. Нет эффективных методов выборки данных
3. Нет механизмов генерации идентификаторов.
4. Нет гарантии целостности выполнения операций (отсутствует транзакционная безопасность)
5. Нет единого формата представления данных
--------------
Как решили эти проблемы - придумали Базы данных
БД - набор таблиц.
Реляционный случай - набор реляционных таблиц.
Таблицы - дочерняя, родительская.
SQL - структурированный язык запросов
1. создание таблиц
2. выборка
3. процедуры
типы SQL-баз данных, MySQL, MS-SQL, Transact SQL, PostgreSQL, Oracle DB, HSQLB, H2
------------------------
Первичный ключ - идентификатор строки, уникальный в таблице. СУБД гарантируют проверку уникальности + автогенерацию
Внешний ключ - ссылка на первичный ключ другой таблицы, СУБД гарантирует целостность данных, как при вставке, так и при удалении.

1) Создать БД с названием SIDIKOV_DB ИЗ pgAdmin
2) Подключиться к БД из нового Maven-проекта с названием test-database
3) Создать таблицу human по скриптам в папке SQL
4) Вставить данные оттуда же
5) Выболнить селекты

JDBC - Java Database Connectivity - драйвера для подключения к БД

имя:" Алеся; DROP TABLE users;"
фамилия:

ДЗ -> с файлов перейти на JDBC
SQL - самостоятельно
Первичный ключ
Внешний ключ
Create
Select
Join
EXISTS
Update
Delete
Insert
Where с условиями
Подселекты
pgAdmin установить

ЗАДАЧА:
1) Создать БД
2) подкчлюиться из IntellijIDEA
3) Заполнить данными и таблицами из папки SQL
4) Реализовать методы isExistById и findByName
5) Запустить и протестировать

-------------------
Абстрактные типы данных - типы данных, имеющие опредленный набор опреций, описанных пользователем.

В Java абстрактные типы данных представляют собой классы.

Стуктуры данных - способ организации данных в памяти компьютера.

АТД
Список 
- положить значение
- удалить значение
- заменить значение
- найти
- т.д.

Структуры данных для списков:
- Массивы
	ограниченный набор элементов с произвольным доступом по индексу
	+ быстрый доступ
	- необходимость сдвигов данных при добавлении в середину
	- необходимость создания нового массива в случае переполнения
- Связные списки - набо узлов с ссылками друг на друга
	+ не требуют сдвигов
	+ не могут быть переполнены
	- нет произвольного доступа - чтобы получить элемент, нужно до него дойти.
	
Схема Список - Связный список - Список на основе массива в Java реализована следующим образом:

Интерфейс List
Реализации интерфейса:
LinkedList
ArrayList

------------------
ДЗ:
1) Думать над проектом
2) Реализовать метод get в Map
3) Модель User в проекте Database должна содержать поле List<Auto> autos;
На запрос findById() должна вернуться модель пользователя со списком всех его машин (одним запросом.)

ПРОЕКТ:
по хорошему - 1 человек - 1 проект
Требования к технологиям:
Обязательно:
БД (PostgreSQL/MySQL) + JDBC/JPA
Логика (предметная область)
Представление - (html/css/javascript через freemarker, либо через rest api) <=> Java Fx

Spring, Maven
-----------------------------------
DI/IOC в Spring :
Вынесение конфигурации связей между классами в отдельные модули, а также возможность их автоматической настройки.

Bean - компонент, имеет id и class, на основе которого он будет создан.

IOC-контейнер - это конейнер, содержащий внутри себя бины, и занимающийся их связываем.
ApplicationContext - IOC-контейнер
Есть две реализации контейнера:
1. ClassPathXmlApplicationContext - получает бины из xml-файла.
2. NOBODY KNOWS  

---------------------
JavaFX

1. Класс Main -> Application (основной класс приложения - отвечает за запуск)
2. fxml-файлы, файлы с java-fx разметкой, они говорят, какие компоненты будут на форме и как они должны выглядеть
3. класс Controller - отвечает за привязку формы к коду

ЗАДАЧА:
1. Создать JavaFX-проект по аналогии с моим
2. Создать сцену с двумя полями для ввода текста, одним Label-ом и одной кнопкой.
3. При нажатии на кнопку, в label должна записываться сумма чисел, введенных в два текстовых поля.

Кнопки, вставляющие в текст html-теги
<h1>
<h2>
<h3>
<table>
<th>
<tr>
<td>

ДЗ:
Сделать проект HtmlEditor
1. Готовый набор тегов
2. При нажатии на кнопку с нужным тегом, данный тег вставляется между строками:

До нажати на тег <table>:

Привет, как дела?

Пусть каретка стоит между запятой и как дела. Тогда после вставки тега будем иметь следующее:

Привет,
<table>

</table>
как дела?

При этом каретка должна быть между <table> и </table>

ADVANCED: отслеживать уровни вложенности.
<tr>

</tr>

<tr>
	<td>
	
	</td>
</tr>

К ВОСКРЕСЕНЬЮ:
Иметь идею проекта + описание функционала. От каждого. НЕ НА СЛОВАХ
----------------------------
Клиент-серверное взаимодействие
Клиент - посылает запросы серверу.
Клиентов много - сервер один.

HTTP - Протокол передачи гипертекста (https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI)
Состоит из запросов и ответов.

ЗАПРОС:
МЕТОД ЗАПРОСА - GET, POST, PUT, DELETE и т.д.
URL-запроса, на который посылаем запрос
Параметры запроса - стоят после ?-знака, разделяются - &
Заголовки(Headers) - сопроводительная информация
Тело запроса - либо текст, либо файлы, либо что-то еще в разных форматах  (только на POST и PUT запросы)

ОТВЕТ:
статус ответа - 200 (OK), 404 (Not found)
заголовки, тело ответа (для любого)

Работа с HTTP в java
Сервлеты (Servlets) - интерфейсы и реализующие их классы для работы с клиент-серверным взаимодействием.

Контейнер сервлетов - содержит в себе множество упакованных в war-архив сервлетов. (Tomcat)

Деплой - процесс размещения war-архива в контейнере сервлетов.

----- ИНСТРУКЦИЯ
Создать maven проект

https://archive.apache.org/dist/tomcat/tomcat-8/v8.0.28/bin/

Указать, чтобы он собирался как war-архив

Подключить зависимость с сервлетами

Описать сервлеты - отнаследовать класс HttpServlet и переопределить необходимые методы, например doGet, в качестве параметров он принимает - HttpServletRequest и HttpServletResponce.

Создать и настроить конфигурацию war-файла - создать папку webapp, создать подпапку WEB-INF, и создать файл web.xml

Внутри web.xml описываем сервлеты и говорим, на какие запросы он должен реагировать (путь).

Настраиваем tomcat в IDE:

Run -> Edit Configurations -> + -> Tomcat Server -> Local,  Name -> Tomcat

Вкладка Deployment -> + -> Artifact -> Выбираем первый war-файл

Возвращаемся во вкладку Server, чистим Before Launch, там же набираем RunMavenGoal, и пишем clean package

Что имеем:

При запуске приложения сначала произойдет сборка maven-ом
Запустится tomcat
На томкат задеплоится приложение
Tomcat обычно запускается на порту 8080
--------------------
JSP - страницы - это HTML + JSP-теги (например c:forEach)
Когда Tomcat получает запрос на загрузку страницы, то jsp-страница компилируется в обычный сервлет и этот сервлет отдает html-код.

+ - удобно, можно встроить  java-код в страницу
+ - хорошо интегрируется с java-сервлеты

- - все плюсы.

Плохое разделение между представлением, данными и логикой. Сложные теги. Слишком большая свобода действий на логике представление.

Лучшее решение:
1) Freemarker - компилирующий обработчик шаблонов (есть документ-шаблон, неважно какого-типа, и мы в этот документ подставляем данные).
HTML-шаблон, данные приходят с сервера.
2) Spring MVC - реализация ModelViewController-подхода в Spring
	* Controller - сервлет, внутри инфраструктуры Spring
	* View - либо Freemarker/HTML/JSP-страница
	* Model - данные + логика
3) SpringBoot - МОЩНЕЙШАЯ библиотека для автоматического деплоя, сборки, конфигурации.

--------------------
Java + Annotation конфигурация Spring-а

Есть классы, есть объекты. 
Объекты зависят друг от друга (например, объект UsersDaoJdbcTemplsteimpl зависит от объекта DataSource, а объект SimpleController зависит от объекта UsersDao)
Каждый объект - это компонент (бин). Следовательно, нужно правильно описать зависимости между бинами.
Раньше - в xml через constructor-arg, property

Теперь есть несколько вариантов:
1) Аннотация @Bean
Данной аннотацией помечаются методы, результатом выполнения которых являются бины.
@Bean
T beanName() {
	return new T();
}

Тогда, данный метод создает бин класса T,
с id = beanName

Методы, помеченные аннотацией @Bean работают, только тогда, когда класс, в котором они описаны помечен аннотацией @Configuration

2) Аннотация @Component - если пометить класс данной аннотацией, то Spring сам создаст экземпляр данного класса и сделат его бином.

Оба способа хорошо работают с аннотацией @Autowired
Данная аннотация вешается на поле, на конструктор либо на setter.
Данная аннотация позволяет спрингу самому найти кандидата для связывания и связать его с вашим бином.

---------------------
ORM - ObjectRelationMapping - технология, которая позволят проводить реляционно-объектые отображение( например, SQL <-> Java Object)
На основе определенной информации механизм сам генерирует SQL-запросы.

Доступный функционал ORM-подхода в java стандартизировать в javax.persistence - JPA.
Что входит в JPA:
1) @Entity
2) @Table
3) @Id
4) @OneToMany
5) @ManyToOne
6) @ManyToMany
7) @OneToOne
8) EntityManager
Hibernate - ORM-фреймворк, реализация JPA
SessionFactory - интерфейс hibernate, предоставляет доступ к сессиям БД
LocalSessionFactoryBean - класс Spring, который реализует интерфейс SessionFactory и хорошо интегрируется со спрингом.

Spring JPA - библиотека spring.orm
Содержит механизмы для реализации концепции "репозиториев" - те же DAO, только с автогенерацией кода.

В случае, когда клиентское приложение само решает, каким образом выводить данные, следует использовать API-подход.
То есть, сервер предоставляет клиенту лишь данные, но сервер не решает, как именно следует выводить информацию. (в случае использования толстого клиента - например, java-fx-приложение, мобильное приложение, отдельный статик-серврер)

REST API - подход. 
Сервер предоствляет набор http-запросов, которые позволяют вытащить данные с сервера или произвести определенную логику работы.
Данные с сервера и на сервер обычно передаются в формате json/xml.

https://ru.wikipedia.org/wiki/JSON

DTO-слой, это слой объектов
DataTransferObject - объект передачи данных. От обычных моделей отличается тем, что содержит только те данные, которые действительно необходимо передавать.

-------------------
1) Установить npm с нодой:
https://nodejs.org/en/
Скачивать LTS версию и запустить установку.
2) Проверить:
npm -version в Git Bush
3) Спуллить мои изменения:
git pull
   
7) Открываем папку со StaticServer в git bush.
8) npm install express 
9) Убеждаемся, что в папке с проектом есть node_modules.
10) Run -> Edit Configuration -> + -> NodeJs:
Working Directory - текущую рабочу папку с проектом
JavaScript File -> server.js
11) Запускаем через зеленую стрелку проект, и отдельно сервер.
12) Проверяем работоспособность.

ДОМА:
1) Для тех, у кого нет репозитория: скачать свою zip-папку с почты. Дома запустить сервер java и сервер со статикой (см. инструкцию выше) + создать бд
2) Проверить работоспособность
3) Привести форму в порядок, добавить нужные поля на форме,
добавить нужные поля в модель бд и т.д.

REST-запросы

POST /users/{user-id}/messages
GET /users/{user-id}/notes

------------------------------------------
Наиболее известные аннотации и их принадлежность:
@Autowired
@Bean
@Configuration
@SpringBootApplication
@Component
@Service
@Repository
@Controller
...
- Spring Context/Beans/MVC/SpringBoot
--------------------------
@OneToOne
@OneToMany
@ManyToOne
@ManyToMany
@Entity
@Table
@JoinColumn
@Column
@Id
@GeneratedValue
...
- JPA
--------------------------
@Override - JAVA
--------------------------
@Query
@NamedQuery
- Spring JPA

В проекте создать папку lib
В нее вставить jar-файл из папки с другим проектом.
File -> Project Structure -> Libraries -> + -> Java -> Выбираете jar из папки lib проекта
spring-web
File -> Project Structure -> Libraries -> + -> Maven -> spring-web -> org.springframework:spring-web:4.3.9.RELEASEspring-web -> OK -> OK ...
jackson-databind File -> Project Structure -> Libraries -> + -> Maven -> jackson-databind -> com.fasterxml.jackson.core:jackson-databind:2.9.0.pr4 -> OK -> OK ...











