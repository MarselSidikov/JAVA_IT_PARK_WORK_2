27(10) -> 11011(2)

27 : 2 = 13 + 1 ост, 27 = 13 * 2 + 1
13 : 2 = 6 + 1 ост, 13 = 6 * 2 + 1
6 : 2 = 3 + 0 ост, 6 = 3 * 2 + 0
3 : 2 = 1 + 1 ост, 3 = 1 * 2 + 1
1
--------------------------
43210 - разряды
11011 - число
1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 27

--------------------------
Какой диапазон чисел можно
 выразить n-количеством битов?
 
 Пусть n = 2, диапазон = 0 .. 2^2 - 1
 
 00 -> 0
 01 -> 1
 10 -> 2
 11 -> 3

 Пусть n = 3, диапазон = 0 .. 2^3 - 1
 000 -> 0
 001 -> 1
 010 -> 2
 011 -> 3
 100 -> 4
 101 -> 5
 110 -> 6
 111 -> 7
 
 int занимает в памяти 4 байта. В одном байте - 8 бит.
 Следовательно, максимальное значение, которое
 можно положить в переменную типа int - 2^32 - 1
 
 НО! На самом деле с int все по-другому.
 Используются только 31 бит из 32-х.
 Потому что 1-й бит уходит под знак числа.
 Если первый бит - 0, число положительное
 Если первый бит - 1, число отрицательное.
 
 1 байт int-а - 8 бит
 00000001 - 1
 10000001 - -1

 Например -27 в int будет выглядеть так:
 int a = -27;
 10000000 00000000 00000000 00011011
 
 В инте на самом деле: -2^31 .. 2^31 - 1
 
 int - 4 байта, -2^31 .. 2^31 - 1 диапазон
 
 int - тип данных
 Тип данных:
 - набор возможных значений 
 - набор возможных операций над значениями
 
 int:
 - целые числа в диапазоне -2^31 .. 2^31 - 1
 - +, -, *, /, %
 
 Объявление переменной на java:
 ТИП имя = нач_знач;
 int a = 27;
 int b; // по умолчанию ноль
 
 / - операция деления. Если слева целое, и справа целое, 
 то выполняется целочисленное деление - остаток полностью отбрасывается
 % - взятие остатка от деления
 То есть:
 Любое число можно выразить формулой:
 n = k * m + t;
 
 n / m = k;
 n % m = t;
 
 У себя в папке с фамилией создаете папку 
 ClassWorks
 Там создаете папку Task1
 В ней сохраняем решение задачи:
 int a = 13768; // сумма, которую хочет выдать банкомат
 // определить количество купюр каждого номинала
 // которое следует выдать банкомату
 5000 - 2
 1000 - 3
 500 - 1
 100 - 2
 50 - 1
 10 - 1
 5 - 1
 2 - 1
 1
РЕШЕНИЕ:
----------------------------
int a = 13768; // 5000 * 2 + 3768
		
		int a5000 = a / 5000; // a5000 = 2
		System.out.println("5000 - " + a5000);
		a = a % 5000; // a = 3 768
		
		int a1000 = a / 1000; // a1000 = 3
		System.out.println("1000 - " + a1000);
		a = a % 1000; // a = 768
		
		// и т.д.
-----------------------------
Именование переменных:
camelCase
camel_case - не так
System.out.println("Hello" + 10);
Выведет - Hello 10
+ - сцепляет строки
Scanner - модуль, позволяющий читать информацию с клавиатуры
Чтобы он работал в программе необходимо его импортировать:
import java.util.Scanner;
Чтобы его использовать необходимо создать его экземпляр:
Scanner scanner = new Scanner(System.in);
Функция nextInt ожидает ввода числа с клавиатуры:
int a = scanner.nextInt();
после того, как пользователь введет число, и нажмет enter оно
попадет в переменную <a>

Домашняя работа:
Создаем на GoogleDrive папку HomeWorks.
В них делаем папки
Task1
Task2
...
В каждую папку заливаем только Program.java - файл

ДЗ:
1) Доделать банкомат, сделать считывание и вывод
всех купюр
2) Считать три числа - a,b,c. Вывести их сумму.
3) Считать два числа - a,b - вывести их частное
4) Считать два числа - a,b - вывести остаток от деления a на b
5) Считать число - 3 знака (0..255), вывести его двоичное представление.
циклы и условия запрещены.

------------------------------------------
Условный оператор if ... else

if (условие_1) {
	действия_при_выполнении_условия_1
} else {
	действия_при_НЕвыполнении_условия_1
}

if (условие_1) {
	действия_при_выполнении_условия_1
} else if (условие_2) {
	действия_при_НЕвыполнении_условия_1
	И_при_выполнении_условия_2
} else {
	действия_при_невыполнении_верхних_условий
}

if (условие_1) {
	действия_при_выполнении_условия_1
}
if (условие_2) {
	действия_при_выполнении_условия_2
}

ОЧЕНЬ ВАЖНО:

Скобки - фигурные { ОБЛАСТЬ_ВИДИМОСТИ }
В области видимости нельзя повторно объявить переменную

МОЖНО:

if (e) {
	int b = 10;
} else {
	int b = 5;
}

НЕЛЬЗЯ:
if (e) {
	int b = 10;
	if (u) {
		int b = 10;
	}
}

a && b - одновременно условие a и условие b истинны
a || b - истинно либо a, либо b, либо одновременно истинны

a += 10; // a = a + 10;
a /= 10 // a = a / 10;

ЦИКЛ - структура управления, делаем действие пока условие цикла
истинно
Один шаг цикла - итерация.

ДЗ:

6) Считать в цикле 10 чисел, посчитать сумму четных
7) Считать в цикле 10 чисел, посчитать произведение нечетных
8) Считать в цикле 10 чисел,  посчитать сумму чисел, оканчивающихся на 7

ТРЕБОВАНИЕ!!!!!
Отступы, форматирование, именование

ДЗ для любимчиков:
ClassWorks - Task3, Task4, Task5
3 - Вывести EVEN если считанное число - четное, NOT EVEN если нечетное
4 - Угадайка
5 - Вывести четные числа от 0 до n, n - с клавиатуры

Условие в циклах и в условных операторах называются "выражениями" - expression
expression имеет тип.

Условие - это такое выражение, которое имеет тип boolean

тип boolean - true/false, занимает в памяти один байт.

Задача: проверить, является ли число простым.

Если число простое - выводим на экран PRIME, если составное - NOT PRIME.
Число подается с клавиатуры.

Простое число - делится на себя и на 1.

Алгоритм проверки простоты числа:
X - входное число
1) Алгоритм в лоб: делить число X на все числа [2..X-1]
2) Алгоритм чуть быстрее: делить число X на все числа [2..x/2]
19
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
3) Алгоритм еще быстрее: делить число X на все числа [2..корень(x)]
	 i * i <= x
Пока (i <= корень(х)) {
	если (x делится нацело на i) {
		сразу говорим, что число не простое
	}
}

если цикл выполнился, и мы не нашли делителей, то говорим, что простое

ВАЖНО:
ПРЕЖДЕ ЧЕМ ИСПОЛЬЗОВАТЬ ПЕРЕМЕННУЮ ЕЕ НАДО ОБЪЯВИТЬ И ПРОИНИЦИАЛИЗИРОВАТЬ

ДЗ:
Везде на вход сначала подается число N, а затем
N-штук чисел

9) Найти минимальное число среди N чисел
10) Найти максимальное число среди N чисел
11) Найти среднее арифмитическое чисел
12) Найти количество локальных максимумов
	a_пред < а_тек > a_след
	а_тек - локальный максимум

6
12
16 - локальный максимум
8
11 - локальный максимум
9
7
ОТВЕТ: 2

БИНАРНЫЕ ЛОГИЧЕСКИЕ ОПЕРАТОРЫ:
a == b - true, если a равно b
a != b - true, если a не равно b
a <= b
a >= b
УНАРНЫЙ ЛОГИЧЕСКИЙ ОПЕРАТОР:
!a - не a, true - если a - false, false - a - true

double - вещественный тип, 8 байтов
СМ. мантисса
https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8

https://ru.wikibooks.org/wiki/Java/%D0%A2%D0%B8%D0%BF%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85

/ - если слева целое и справа целое, то результат тоже целое
/ - если какое либо из чисел вещественное, то результат считается вещественным (с точкой, дробь)
Неявное преобразование - int -> double
Явное преобразование - double -> int, явное преобразование необходимо проводить, когда возможна потеря данных. 

130 в int
00000000 00000000 00000000 10000010
byte:
10000010 - дополнительный код для -127

Что такое дополнительный код?????
-127

В двоичном коде положительное 127
01111110
Код инвертируется - получаем обратный код
10000001
Получаем дополнительный код: прибавляем 1:
10000010

ЗАЧЕМ ЭТО НАДО? 

27 - 5, что делает компьютер:
Заменяет вычитание сложением:

27 + (-5)
Как получить -5?

Пять как положительное:
101
Например, используем 8 разрядов:
00000101
Получаем обратный код:
11111010
Получаем дополнительный код:
11111011
Складываем 27 в двоичном коде и дополнительный код для -5:
 00011011
 11111011
100010110
 00010110

МАССИВЫ - структура данных, представляющая собой
набор переменных.
Каждая переменная доступна по индексу (порядковому номеру)

Объявление массива c последующей инициализацией:
int a[] = new int[5]; // объявили массив из 5 переменных
a[0] = 7;
a[1] = -2;
a[2] = 3;
a[3] = 1;
a[4] = 1;
System.out.println(a[0]); // 7

Явная инициализация массива:
int a[] = {7, 1, 3, 1, 1};

Task7 - Явно проинициализировать массив из 
6 чисел числами 5, 2, 1, 5, 6, 7
Считать два числа i и j.
Поменять местами в массиве элементы под 
позициями i и j. Вывести полученный массив.

5 2 1 5 6 7
при n = 6

a[0] <-> a[6] : a[n - 1 - 0]
a[1] <-> a[5] : a[n - 1 - 1]
a[2] <-> a[4] : a[n - 1 - 2]

i = {0..2}
a[i] <-> a[n - 1 - i]
----------------------------
int i = 0;
while (i < n) {
	System.out.println(i);
	i++;
}
Можно заменить:
for (int i = 0; i < n; i++) {
	System.out.println(i);
}

for (объявление переменной цикла; условие окончания цикла; шаг цикла) {
	// что делаем в цикле
}

ДЗ для всех кроме (Рустем, Валерий, Александр А., Рустам)
13) сумма всех элементов массива
14) среднее арифмитическое элементов массива
15) количество элементов, стоящих на четных позициях
16) разворот массива с помощью цикла for
ДЛЯ ВСЕХ ЗАДАНИЙ МАССИВ ИНИЦИАЛИЗИРУЕМ ЯВНО

ДЗ для Advanced:
17) Удалить из массива все дубликаты
------------------------------------
В java есть две группы типов:
1) примитивные - сама переменная непосредственно 
содержит в себе значение.
int a = 6, в памяти выделяется 4 байта и они
непосредственно хранят в себе значение 6.
оперативная память [][][6][][][][]
						a
К примитивным типам относятся:
int, char, boolean, double, float, byte,
long, short

2) Ссылочные типы данных - переменная хранит
только адрес реального значения.
К ссылочным типам относятся массивы и классы.

int x[] = {-3, 4, 5};

В оперативной памяти выделется память под массив,
и в переменную x кладется адрес первого
байта массива.

оперативная память - [][][][-3][4][5]
оперативная память - [null][][адес -3][][][адрес -3][][]
					 u	      x             y
						 
int y[] = x;
в переменную y скопируется значение x

int u[]; // u - null
----------------------------------
Сортировка массива - упорядочивание элементов массива
-4 5 1 2 10 12 -7 => -7 -4 1 2 5 10 12

Сортировка вставками:

Пусть есть массив x[0..n-1]
1) Положим a = 0, b = n-1
2) Найдем минимальный элемент min в дапазоне [a..b]
3) Поменяем местами x[a] <=> min
4) Теперь a = a + 1
5) Повторим шаги 2-5

Реализация:
-4 5 1 2 10 12 -7, min -7
-7 5 1 2 10 12 -4, min -4
-7 -4 1 2 10 12 5, min 1
-7 -4 1 2 10 12 5, min 2,
-7 -4 1 2 10 12 5, min 5
-7 -4 1 2 5 12 10, min 10
-7 -4 1 2 5 10 12, min 12
-7 -4 1 2 5 10 12 - конец

Сортировка пузырьком:

Пусть есть массив x[0..n-1]
1) Пусть i = n -1
2) Пусть j = 0
3) Пока j меньше i, если x[j] > x[j+1], меняем местами 
4) Дошли до i -> i - 1, повторяем 2-4

-4 5 1 2 10 12 -7

при i = n - 1 = 6 
-4 и 5 - -4 меньше, все нормально
-4 5 1 2 10 12 -7
5 и 1 - 5 больше, меняем местами
-4 1 5 2 10 12 -7
5 и 2 - 5 больше, меняем местами
-4 1 2 5 10 12 -7
5 и 10 - 5 меньше, все нормально
-4 1 2 5 10 12 -7
10 и 12 - все нормально
-4 1 2 5 10 12 -7
12 и -7 - меняем местами
-4 1 2 5 10 -7 12 - самое большое число в конце

теперь i = i - 1, повторяем все заново

ДЗ:
18) Реализовать вставками без гугла
19) Реализовать пузырька тоже без гугла

Пример вложенного цикла:
for (int i = 0; i < 5; i++) {
	for (int j = 0; j < 5; j++) {
		System.out.println(i + j);
	}
}

Для i = 0 программа выведет:
0 + 0 = 0
0 + 1 = 1
0 + 2 = 2
0 + 3 = 3
0 + 4 = 4
Для i = 1 программа выведет:
1 + 0 = 1
1 + 1 = 2
1 + 2 = 3
1 + 3 = 4
1 + 4 = 5
----------------------------------------
Задача: 
Пусть int a[] = {4, 5, 9, 2, 1};

Надо, чтобы в x = 45921;

7324 = 7 * 1000 + 3 * 100 + 2 * 10 + 4 * 1

Task13
Считать число - 3 знака (0..255), 
вывести его двоичное представление.
Циклы, условия и массив необходимы

-------------------------------------------------------
int, double, boolean
long  float
short
byte

char - символьный тип, 2 байта

Таблица кодировки - каждому символу
сопоставляется определенное число.

Две наиболее известные кодировки:
ASCII
0 - 31 управляющие непечатные символы
\n - переход на новую строку
\t - табуляции
\r - возврат каретки
32 - 127 - печатные символы латинского алфавита
65 - 90 - заглавные буквы английского алфавита
97 - 122 - строчные буквы английского алфавита
127 - 255 - печатные символы регионального языка

Один символ в кодировке ASCII занимает 1 байт

проблемы - если на машине не установлен язык,
документ превращается в крякозябры

Решение - выделить под каждый символ 2 байта
Таким образом можно закодировать 65 000 символов 
- это Unicode 

char -> int неявное преобразование
int -> char - явное преобразование

ДЗ:
20) Пусть имеется сторка '3','2,'3','1', надо получить
число int x = 3231
21) Получить text аналогично как в 21 и вывести
все знаки препинания
22) Считать два массива символов с консоли:
char text[] - максимальная длина 100
char word[] - максимальная длина 10
Сначала считать число n - количество 
символов в text, которые вы захотите ввести
Потом считать сами символы text
аналогично для word
Найти позицию вхождения word в text
Например:
text = abbbabbc
word = bc
Результат работы программы: 6


----------------------------------
Подрограммы - наборы инструкций, внутри основной программы.
Данный набор может быть многократно вызван по имени.

Придумали:
1) Чтобы избежать дублирования кода
2) Чтобы избежать ошибок

Вид подпрограммы:

имя(набор_формальных_формальных_параметров) {
	// тело подпрограммы
}

Подрограммы - функции и процедуры

Процедура - набор инструкций с именем, телом и формальными парамтами

static void имя_процедуры(набор_формальных_параметров) {
	// тело
}

Вызов процедуры:
имя_процедуры(набор_аргументов).
Аргументы передаются в формальные параметры

main - входная точка приложения - процедура.

Аргументы в формальные параметры копируются.
В формальный параметр копируется значение аргумента.
Если аргумент примитивный - копируется содержимое.
Если аргумент ссылочный - копируется ссылка на объект в памяти.
Таким образом процедура работает с самим объектом.

Task15
Написать процедуру вывода всех чисел массива,
меньших числа number
static void showLess(int array[], int number)

Task16
Минимальный и максимальный элементы поменять местами

Функция - разновидность подпрограммы.
Функция в отличие от процедуры может явно возращать
значение своего выполнения.

public static int sum(int a, int b) {
	int s = 0;
	for (int i = a; i <= b; i++) {
		s = s + i;
	}
	
	return s;
}

// return - возвращает значение туда, где была вызвана функция
public static void main(String args[]) {
	int mySum = sum(5, 10); // после выполнения функции вместо sum(5, 10) будет лежать значение суммы
	double average = mySum / 6.0;
}

Task16
Написать три функции - 
поиск минимального в массиве, {2, 3, -4, 3} -> -4
поиск максимального в массиве {2, 3, -4, 3} -> 3
поиск номера элемента в массиве {2, 3, -4, 3}, -4 -> 2, первое вхождение, если ничего не нашли -1
процедура, меняющая в массиве элементы i и j
Процедура:
Поменять максимальный и минимальный элементы местами
используя описанные функции

ДЗ:
Доделать классные и разобрать

--------------------
Добавление элемента в конец массива
Пусть есть пустой массив A
[ ] [ ] [ ] [ ]
 0   1   2   3

Если добавляем * в массив, куда мы ее положим? - A[0]

[*] [ ] [ ] [ ]
 0   1   2   3

Теперь, куда добавим еще одну *? - A[1]

[*] [*] [ ] [ ]
 0   1   2   3

----------------------------
Добавление элемента в начало массива
[*] [**] [***] [ ] [ ]
  0   1     2    3   4
Как добавить в начало ****?
1) [*] [**] [***] [***] [ ]
    0     1    2     3   4

2) [*] [**] [**] [***] [ ]
3) [*] [*] [**] [***] [ ]
4) [****] [*] [**] [***] [ ]

Задача:

Скопировать мой код

addToIndexOfArray(int a[], int value, int index)

------------------------------------------
Типы данных - примитивные, ссылочные - массивы.
Это встроенные типы.

Пользовательские типы - типы, определенные программистом.
Такие типы - абстрактные.

Абстрактные типы данных ~ классы.

Это типы данных, полученные методами
абстракции.

Абстракция - сущность, характеристики
которой определены в контексте
решаемой задачи. То есть эта сущность
имеет только те характеристи, которые
необходимы для решения задачи.

Сущность "Студент" - абстракция.

Задача: университет
- имя, фамиля, возраст, номер группы
- академ. задолженность
- отработаны ли мероприятия

Задача: семья
- накормлен ли
- где он в субботу вечером
- с кем он в субботу вечером
- ориентация
- в каком состоянии

Задача: военкомат
- когда, где, почему

Класс - общая структура, абстракция.
На основе классов создаются объекты - реальные сущности.
объект - сущность, обладающая:
- параметрами, свойствами, характетиристиками, - СОСТОЯНИЕ
- ПОВЕДЕНИЕ - что может делать объект

Теперь, каким образом мы можем описать класс?

1) Описать, объект может иметь диапазон характеристик
2) Описать его поведение

Как можно описать объект?
Создать его на основе класса, а затем
задать ему характеристики

------------
1) ДЗ - написать класс Животное с его
характеристиками, создать два экземпляра
вывести на экран характеристики каждого
2) В проекте ArraysWorks добавить
метод сортировки пузырьком или вставками
и протестировать на animalsWeight

Два важных понятия жизненного цикла объекта:

1. Шаг - инстантивация - создание экземпляра, выделение памяти (оператор new)
2. Шаг - инициализация - задание начальных характеристик - конструктор

Конструктор - очень похож на метод, но
таковым не является. Набор инструкций, инициализирующих
объект.

По умолчанию каждый класс имеет конструтор без параметров.
Данный конструктор "по умолчанию" инициализирует
каждое поле ее дефолтным значением.
Для int -> 0
Для boolean -> false
Для ссылочных типов (включая String) -> null
Для double -> 0.0

Конструкторы можно определять самим. Но, тогда
конструктор по умолчанию становится недоступным.

ИТОГО:
Конструторы бывают четырех:
1) Конструтор "по умолчанию без параметров"
2) Конструктор пользовательский без параметров
3) Конструктор пользовательский с параметрами
4) Конструктор пользовательский копирования - инициализирует объект полями другого объекта

this - ключевое слово, указываемое перед обращением
к члену класса внутри самого класса.
this - объектная переменная.
DEBUG - отладка программы.
Breakpoint - точка останова. Строка, на которой
программа должна остановить выполнение.

Программист на Java всегда выступает в двух ролях:
1) Разарботчик класса, когда разрабатываем класс мы не пишем инструкции программе, мы
лишь говорим, как она может работать у пользователя.
2) Пользователь класса - пользуется теми инструкциями, которые
описал разработчик класса.

В Main обычно пишут вызовы доступного функционала.

Помимо полей, членами класса также являются методы.
Метод - функция либо процедура описанная внутри класса.

Task17

Описать класс Автомобиль
Поля класса:
Модель
Номер (только числа)
Пробег
Сколько было потрачено топлива
-----
Конструкторы - 
без параметров, 
копирования, 
с параметрами
Методы - 
рассчитать средний расход бензина на 1 км.

В Main все вывести.

http://www.ozon.ru/context/detail/id/7821666/

Пакеты - по сути, папочки.
Нужны для логического разделения классов.
Пусть есть класс cursor - их два.
Один - мышка
Другой - каретка в файле
Называются одинаково. Как разделить?
один - ru.itpark.windows, ru.itpark.text;
Полное имя класса всегда включает пакеты.

Уровни доступа - обычно распространяются на члены 
классов и конструкторы.

Есть 4 уровня доступа:
Закрытый
Открытый
Защищенный
Пакетный

Если у члена класса или конструктора не указан модификатор доступа,
то считается, что у него пакетный уровень доступа

public - модификатор доступа, соответсвующий уровню
доступа открытый. Доступен всегда и везде.

private - модфикатор доступа, соответсвующий уровню доступа
закрытый. Доступен только внутри класса.

В поля класса могут лететь неккоректные данные.
Чтобы обезопасить объект необходимо:

1) Сделать поля закрытыми (private)
2) Сделать set-методы с проверкой данных

Первый принцип ООП - абстракция
Второй принцип ООП - инкапсуляция
1. Совмещение в одной сущности структур данных (поля)
и алгоритмов (методы).
2. Защита внутренней структуры данных
Для чего это нужно?

ИТОГО:

В классе есть
Поля
Конструкторы
Методы
Методы доступа (get-set методы)

Генерация геттеров, сеттеров и конструкторов:
Ставим курсор в текстовое поле с классом
Нажимаем Alt+Insert
Выбираем поля и радуемся жизни

ДЗ 
25):

Описать класс Человек
Имя
Возраст
Пол
Рост
Вес

+ Конструкторы
+ Геттеры
+ Сеттеры
+ Поля

---------------
26) Для Advanced:
Создать массив людей
Данные считать с клавиатуры
Далее, считываете фильтр сортировки:
- по возрасту -> 1
- по росту -> 2
- по весу -> 3

Сортируете, выводите на экран

Список - АТД, поддерживающий опреации
работы с коллекцией как со списком:
положить
удалить
найти
заменить
и т.д.

Список на основе массива - в качестве
хранилища элементов массив - ArrayList

Реализовать концепт Телевизор
ТелевизоР это набор каналов,
каждый канал - набор передач
Есть пуль, пулТь переключает канал
Есть человек, он нажимает на кнопки пульта.
--------------------

Статическое поле (например static int aStaticValue):
1) Является глобальным для всех объектов класса.
2) Могут быть вызваны непосредственно из класса, 
без создания объекта.
3) Могут быть вызваны ДО создания объектов.
4) Нестатические поля инициализируются в конструкторе.
А статические поля инициализируются в статическом инициализаторе.

Зачем они нужны?
Когда поле должно быть глобальным для всех объектов, например:
время для программы
счетчик созданных объектов и т.д.

Нужны статические поля-константы, например 
число PI

Статические методы:
1) Могут быть вызваны из класса без создания объекта
2) Могут работать только со статическими полями класса

Когда нужны статические методы:

КОГДА МОДЕЛИРУЕТСЯ ПОВЕДЕНИЕ ПРЕДМЕТНОЙ ОБЛАСТИ
а не конкретных объектов, например:
Математические функции
Сортировки

ДЗ:
27) Сделать копию ArrayList к себе
    Добавить функции:
    получить пересечение списков (формирует список с элементами, которые есть в двух других (и там и там))
    удалить все дубликаты из списка
28)
    Ресторан - смоделировать предметную область


Advanced:
Изучить связыне списки
Описать класс Node {
	int value;
	Node next;
}
Описать класс LinkedList(имеет поле Node head)
+ реализовать все методы, которые есть в ArrayList
+ изучить внутренние и вложенные классы, 
описать Node как вложенный класс по отношению к LinkedList

-------------------
Наследование:

- Третий принцип ООП. Позволяет объектам классов-потомков
копировать и дополнить (состояние 
и поведение) и переопределять поведение объектов классов-предков.

Наследование в java
Пусть A потомок класса B.
Чтобы это было действительно так, надо написать:
class A extends B {

}
При этом класс А становится потомком класса B, 
и внутри класса A присутствует возможность вызвать
конструктор класса B через super().

Для того, чтобы класс A имел доступ к полям 
класса B, в классе B поля должны быть помечены
модфикатором доступа public/protected.
К полям предка можно обращаться через super (аналогично this).

КОНСТРУКТОР НИКОГДА НЕ НАСЛЕДУЕТСЯ!!!!!!

Пусть класс B имеет метод x();
Если в классе A нет описания метода x(),
то такой вызов: A a = new A(); a.x();
вызовет метод класса B.
Если же мы в классе A напишем СВОЮ реализацию
метода x(), то вызов A a = new A(); a.x();
даст вызов метода в классе A.
Такой механизм называется ПЕРЕОПРЕДЕЛЕНИЕМ МЕТОДА.
ВАЖНЫЙ МОМЕНТ!!!!!!!
метод в потомке должен ПОЛНОСТЬЮ ПОВТОРЯТЬ СИГНАТУРУ МЕТОДА В ПРЕДКЕ
(тип возвращаемого значения, название, формальные параметры)
Если метод в предке и потомке отличаются по:
1. Названию - то это вообще разные методы
2. Если методы отличаются формальными параметрами
то это перегрузка методов.
3. Если методы отличаются типом возвращаемого
значения -будет ошибка.
В Java могут быть два метода с одинаковым названием
и разными формальными параметрами.
Восходящее преобразование.

Объектная переменная - переменная, которая
может содержать ссылку на объект.
У объектной переменной есть тип. Но объект, на который
ссыллаестя объектная переменная не всегда
может быть того же самого типа.

Восходящее преобразование - возможность хранить
в объектной переменной класса-предка ссылку
на объект класса потомка.

Полиморфизм - возможность работать
с объектами разного типа таким образом,
будто они принадлежат одному типу.

Возможность обеспечивается восходящим преобразованием.

Рекомендации по наследованию:
1. Не использовать наследование.
2. Если уж вас угораздило - используйте правило: Класс
A потомок класса B тогда, и только тогда, 
кода любой объект A является B.

Супермен потомок Супергероя, потому что
любой супермен является супергероем.

Велосипед, является потомком транспорта, 
потому что любой велосипед является транспортом

Задание номер:
Task18
Классы прямоугольник, квадрат, трапеция.
Задача: построить правильную иерархию классов
+ вывести на экран площадь каждой фигуры.

Абстрактный класс - класс, экземпляры которого
не могут быть созданы.
Для чего они нужны? Для ЛУЧШЕГО построения иерархий классов, 
а также для более качественного использования полиморфизма.

Абстрактные классы в Java помечаются 
ключевым словом abstract. Экземпляры
таких классов создать нельзя.

Абстрактный метод - метод, у которго нет реализации.
Если в классе есть хотя бы один абстрактный метод,
то весь класс помечается как abstract.
Такие методы ОБЯЗЫВАЮТ всех потомков
данного класса реализовать данный метод.
Если потомок не реализует данный метод,
то он тоже должен быть помечен как abstract.

Task 19
1. Скопировать код Task18 в папку Task19
2. Задача: вывести количество одинаковых фигур.
Фигуры считаются одинаковыми, когда у них
одинаковый периметр и площадь.

Множественное наследование - принцип, когда у 
потомка может быть более одного предка.

В Java множественное наследование запрещено.
НО!
Разрешена множественная имплементация интерфейсов.
Интерфейс - технически - это полностью абстрактный класс,
содержит только абстрактные методы + константы 
(до Java 7).

Интерфейс - семантически - абстракция поведения.

SOLID

https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

S	SRP[5]	
Принцип единственной ответственности (The Single Responsibility Principle)
Существует лишь одна причина, приводящая к изменению класса.
O	OCP[6]	
Принцип открытости/закрытости (The Open Closed Principle)
«программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
L	LSP[7]	
Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование.
I	ISP[8]	
Принцип разделения интерфейса (The Interface Segregation Principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»[9]
D	DIP[10]	
Принцип инверсии зависимостей (The Dependency Inversion Principle)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»[9]

Сравнение в Java:
1) Сравнение примитивных типов
== - сравнивает значения переменных примитивных типов
2) Сравнение ссылочных типов
== - сравнивает ссылки, которые хранятся в сравниваемых объектных переменных 
Сравнение ссылочных типов (классов) по полям можно сделать
переопределив метод equals класс Object.
Метод equals принимает на вход Object, следовательно
вы не можете получить доступ к полям, пока не 
выполните понижающее преобразование.

Класс Object - суперкласс.
Любой класс Java по-умолчанию наследуется от Object.
ЧТО МЫ ЗНАЕМ:

1) Типы данных - int, boolean, double, char операции над ними и размер
2) Утилиты java и javac
3) if, while, for
4) System.in, System.out, System.err
5) Бинарные унарные логические операторы
6) Явное и неявное преобразования
7) переполнение
8) обратный, дополнительный коды
9) массивы, сортировки - пузырьком, вставками
10) Классы, объекты
11) Поля, методы, конструкторы
12) Функции, процедуры -> методы
13) Инкапсуляция
14) Уровни доступа и модификаторы доступа
15) Методы доступа
16) Статические члены классов
17) Наследование, абстрактные классы
18) Полиморфизм, интерфейсы
19) Перегрузка и переопределение методов
20) SOLID
21) Object + equals
22) InputStream OutputStream + FileInputStream + FileOutputStream
23) Сериализация

Advanced TASK:
Сгенерировать список людей из 17 000 записей
Сохранить в файл.
Каждая запись содержит имя возраст.
Считать все это дело из файла, и отсортировать
по возрасту за O(n).
Результат записать в другой файл.
ООП!!!!

////
http://developer.alexanderklimov.ru/android/java/io.php
http://iais.kemsu.ru:8080/odocs/java/Chapter11.html
////

Файл - набор байт на жестком диске с последовательным доступом
Streams - потоки интсрументы, с помощью которых
Java работает с последовательностями байт.
Поток - последовательность байт.
Поток может быть из клавиатуры, из камеры,
может из файла.
По умолчанию Java открывает три потока:
System.in
System.out
System.err

 Пакет java IO(input/output) предназначен для работы с потоками.
 InputStream - верхний класс java IO, отвечает
 за работу с входными потоками.
 Методы:
 * int read() - возвращает один байт из входного потока.
 и переходит к следующему байту.
 Метод возвращает значение от 0 до 255.
 Тип byte не используется потому, что его
 диапазон значений в промежутке -128..127.
 Метод возвразает -1, когда данных.
 * int read(byte b[]) - считывает набор байтов из потока
 в массив b и возвращает количество считанных байт
 FileInputStream - потомок класса InputStream.
 В нем реализован метод read вызовом методоа
 read0, который является native.
 native методы - реализованы в виртуальной машие, реализованы нативно, 
 то есть на C/C++

 OutputStream и его потомок FileOutputStream.
 Работают с выходным потоком.
 
 имеют методы write(int b); write(byte[] b);
 
 ДЗ:
 Реализовать nextInt в своем классе Scanner

 class Scanner {
	private InputStream input;
	
	public Scanner(InputStream input) {
		this.input = input;
	}
	
	public int nextInt() {
		// считываете байты, пока не встретили цифру
		// встретили цифру, преобразуете в int и запоминаете
		// пока у нас идут цифры, каждое преобразуем в int
		// и запоминаем
		
		// возвращаем результат
	}
 }

Сериализация - преобразование объекта в байтовое представление.


























